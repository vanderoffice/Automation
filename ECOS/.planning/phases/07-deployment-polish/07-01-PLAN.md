---
phase: 07-deployment-polish
plan: 01
type: execute
---

<objective>
Harden the Docker production build with proper environment variable injection, optimized multi-stage build, and local production verification.

Purpose: Ensure the production container builds cleanly, serves the app at /ecosform/, and connects to the VPS Supabase instance — all verifiable locally before touching the VPS.
Output: Production-ready Dockerfile, docker-compose.prod.yml, and verified local production build.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files from prior phases:
@Dockerfile
@docker-compose.yml
@nginx.conf
@vite.config.js
@package.json
@src/lib/supabase.js

**Tech stack available:** React 18, Vite 5, Tailwind CSS 3, Supabase JS, nginx:alpine
**Established patterns:** multi-stage-dockerfile, subpath-deployment (/ecosform/), supabase-client-singleton
**Constraining decisions:**
- Phase 01-01: base: '/ecosform/' in vite.config.js, multi-stage Dockerfile already scaffolded
- Phase 02-02: Supabase client uses import.meta.env.VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY
- Phase 02-02: persistSession: false, db: { schema: 'ecos' }

**Infrastructure context (from ~/dotfiles/docs/INFRASTRUCTURE.md):**
- VPS: Ubuntu 24.04, Docker, nginx-proxy + nginx-proxy-acme for auto-SSL
- Existing pattern: VIRTUAL_HOST + VIRTUAL_PATH + LETSENCRYPT_HOST labels
- VPS Supabase PostgREST at supabase-kong container
- VPS IP: 212.38.95.33, SSH alias: `ssh vps`
- Existing vanderdev-website container already runs on VPS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create production docker-compose and harden Dockerfile</name>
  <files>docker-compose.prod.yml, Dockerfile, .env.production.example</files>
  <action>
Create a separate `docker-compose.prod.yml` for production deployment (keep existing docker-compose.yml for dev only).

Production compose should:
- Build from production target
- Use `.env.production` for env vars (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY)
- Set container_name: ecos-form
- Set restart: unless-stopped
- NOT expose ports directly (nginx-proxy handles routing via Docker labels)
- Include labels: VIRTUAL_HOST=vanderdev.net, VIRTUAL_PATH=/ecosform, VIRTUAL_DEST=/, LETSENCRYPT_HOST=vanderdev.net
- Connect to the nginx-proxy external network (network name: `nginx-proxy` — standard on VPS)

IMPORTANT: VIRTUAL_DEST=/ is critical — it strips /ecosform prefix before forwarding to the container's nginx, which expects requests at root. Without this, nginx-proxy would forward /ecosform/index.html to the container, but the container's nginx only listens at /ecosform/ via alias. The VIRTUAL_DEST=/ tells nginx-proxy to rewrite the path.

Update Dockerfile production stage:
- Add HEALTHCHECK (curl localhost:80 or wget)
- Add proper labels (maintainer, description)

Create `.env.production.example` with placeholder values:
```
VITE_SUPABASE_URL=https://YOUR_VPS_IP:8443
VITE_SUPABASE_ANON_KEY=YOUR_ANON_KEY
```

Note: Vite injects VITE_ env vars at BUILD time (not runtime). The docker-compose.prod.yml needs to pass these as build args, and the Dockerfile needs ARG + ENV to make them available during `npm run build`.
  </action>
  <verify>
`docker compose -f docker-compose.prod.yml config` validates without errors.
Dockerfile syntax valid (docker build --check if available, or just visual review).
.env.production.example exists with correct variable names.
  </verify>
  <done>
Production compose file exists with correct nginx-proxy labels, external network, build args for Supabase env vars. Dockerfile has HEALTHCHECK. .env.production.example documents required variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build and verify production container locally</name>
  <files>docker-compose.prod.yml, nginx.conf</files>
  <action>
Create a temporary `.env.production` with the dev Supabase URL/key (from .env.local) so we can test the production build locally.

Build the production image:
```bash
docker compose -f docker-compose.prod.yml build
```

Run the container locally (temporarily expose port 8080:80 for testing — override in command, don't change the compose file):
```bash
docker compose -f docker-compose.prod.yml up -d
```

Verify:
1. Container starts and stays healthy
2. curl http://localhost:8080/ecosform/ returns HTML with React root div
3. curl http://localhost:8080/ecosform/assets/ returns JS/CSS bundles
4. SPA routing works: curl http://localhost:8080/ecosform/workflow returns the same index.html (not 404)

If nginx routing issues found, fix nginx.conf. The current config uses `alias` with `try_files` which should handle SPA routing correctly.

After verification, stop and remove the test container. Remove the temporary .env.production (it contains real keys — should not be committed).

Ensure .env.production is in .gitignore.
  </action>
  <verify>
Production Docker image builds successfully.
Container starts without errors.
curl http://localhost:8080/ecosform/ returns 200 with HTML content containing "root" div.
curl http://localhost:8080/ecosform/workflow returns 200 (SPA fallback working).
Container removed after testing.
.env.production in .gitignore.
  </verify>
  <done>
Production container builds, starts, serves /ecosform/ correctly with SPA routing, and is cleaned up. .env.production gitignored.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker compose -f docker-compose.prod.yml config` validates
- [ ] Production image builds without errors
- [ ] Container serves /ecosform/ with correct SPA routing
- [ ] .env.production.example committed, .env.production gitignored
- [ ] No test containers left running
</verification>

<success_criteria>

- All tasks completed
- Production Docker config verified working locally
- Environment variable injection pattern proven (VITE_ build args)
- nginx-proxy labels correctly configured
- Ready for VPS deployment (07-02)
</success_criteria>

<output>
After completion, create `.planning/phases/07-deployment-polish/07-01-SUMMARY.md`
</output>
