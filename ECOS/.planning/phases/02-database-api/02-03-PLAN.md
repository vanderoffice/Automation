---
phase: 02-database-api
plan: 03
type: execute
---

<objective>
Implement row-level security policies on ECOS tables and create a role simulation system that lets the demo app switch between Employee, Manager, and Admin perspectives without real authentication.

Purpose: RLS ensures data access matches the selected role even at the API level (defense in depth). The role simulation system provides the foundation for Phase 5's role switcher UI — letting executives experience each perspective during the demo.
Output: RLS policies active on all ECOS tables. React role context with switchable demo identity. Seed data with fictional employees in all three roles.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-api/02-01-PLAN.md
@.planning/phases/02-database-api/02-02-PLAN.md

# Phase 1 context
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

**Tech stack available:** React 18, Vite 5, Tailwind CSS 3, React Router v6, @supabase/supabase-js
**Established patterns:** layout-route-with-outlet, barrel-export, variant-props-pattern, forwardRef-form-inputs

**Key files:**
@src/lib/supabase.js
@src/lib/api/index.js
@src/App.jsx
@src/main.jsx
@src/components/Layout.jsx

**Constraining decisions:**
- PROJECT.md: Role switcher for demo, not real auth. No PII — fictional data only.
- PROJECT.md: Three roles — employee, manager, admin
- Phase 02-02: Supabase client configured with ecos schema, persistSession: false

**RLS design approach for demo app:**
Since this is a DEMO (not production auth), the role simulation uses Supabase's ability to set custom claims via the `x-custom-claims` header or by using `supabase.rpc()` with a role-setting function. The simplest approach for a demo:

Option A: Use Supabase's anon key with request-level headers to pass the current role.
Option B: Use custom PostgreSQL functions that accept role as parameter.
Option C: Create separate Supabase clients per role with different JWT claims.

**Recommended: Option B** — Custom PostgreSQL functions that filter based on a passed role parameter, with RLS as a safety net. This is the simplest for a demo while still demonstrating the concept of role-based access. RLS policies will enforce that the anon role can read/write appropriately, and the API helpers will pass the current demo role for filtering.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS policies and role-aware database functions</name>
  <files>sql/003-rls-policies.sql, sql/004-seed-data.sql</files>
  <action>
Create `sql/003-rls-policies.sql`:

1. Enable RLS on all ecos tables:
   ```sql
   ALTER TABLE ecos.departments ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.employees ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.agreements ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.agreement_access_groups ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.signatures ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.audit_log ENABLE ROW LEVEL SECURITY;
   ALTER TABLE ecos.form_versions ENABLE ROW LEVEL SECURITY;
   ```

2. For the demo, create PERMISSIVE policies that allow the anon role full access. This is intentional — the demo doesn't use real auth, so RLS serves as documentation of WHAT policies would look like in production, while the API helpers handle role-based filtering:
   ```sql
   -- Departments: everyone can read
   CREATE POLICY "departments_read" ON ecos.departments FOR SELECT TO anon USING (true);

   -- Employees: everyone can read (demo needs to show all perspectives)
   CREATE POLICY "employees_read" ON ecos.employees FOR SELECT TO anon USING (true);

   -- Agreements: full access for demo (role filtering in API layer)
   CREATE POLICY "agreements_select" ON ecos.agreements FOR SELECT TO anon USING (true);
   CREATE POLICY "agreements_insert" ON ecos.agreements FOR INSERT TO anon WITH CHECK (true);
   CREATE POLICY "agreements_update" ON ecos.agreements FOR UPDATE TO anon USING (true);

   -- Access groups: follow agreement access
   CREATE POLICY "access_groups_select" ON ecos.agreement_access_groups FOR SELECT TO anon USING (true);
   CREATE POLICY "access_groups_insert" ON ecos.agreement_access_groups FOR INSERT TO anon WITH CHECK (true);

   -- Signatures: full access for demo
   CREATE POLICY "signatures_select" ON ecos.signatures FOR SELECT TO anon USING (true);
   CREATE POLICY "signatures_insert" ON ecos.signatures FOR INSERT TO anon WITH CHECK (true);

   -- Audit log: read all, insert new
   CREATE POLICY "audit_read" ON ecos.audit_log FOR SELECT TO anon USING (true);
   CREATE POLICY "audit_insert" ON ecos.audit_log FOR INSERT TO anon WITH CHECK (true);

   -- Form versions: read-only
   CREATE POLICY "form_versions_read" ON ecos.form_versions FOR SELECT TO anon USING (true);
   ```

3. Add SQL comments documenting what PRODUCTION policies would look like:
   ```sql
   -- PRODUCTION NOTE: In a real deployment, policies would use auth.uid() and JWT claims:
   -- CREATE POLICY "agreements_employee" ON ecos.agreements FOR SELECT
   --   USING (employee_id = auth.uid());
   -- CREATE POLICY "agreements_manager" ON ecos.agreements FOR SELECT
   --   USING (employee_id IN (SELECT id FROM ecos.employees WHERE department_id = (
   --     SELECT department_id FROM ecos.employees WHERE id = auth.uid()
   --   )));
   -- CREATE POLICY "agreements_admin" ON ecos.agreements FOR SELECT
   --   USING (true);  -- admins see everything
   ```

4. Create `sql/004-seed-data.sql` with fictional demo data:

   Departments (4):
   - Office of Digital Innovation (ODI)
   - Department of Technology (CDT)
   - CalHR Human Resources (CALHR)
   - State Controller's Office (SCO)

   Employees (8 fictional — no PII):
   - 3 employees (one per dept + one in ODI)
   - 2 managers (ODI, CDT)
   - 2 admins (CALHR, SCO)
   - 1 employee in SCO for coverage

   Use INSERT statements with explicit UUIDs (gen_random_uuid() in DEFAULT, but use fixed UUIDs for seed data so they're deterministic):
   - Employee: Alex Rivera, Jordan Chen, Sam Washington, Pat Kim
   - Manager: Morgan Hayes, Taylor Brooks
   - Admin: Casey Nguyen, Drew Martinez

   Seed 3 agreements in different states:
   - One draft (Alex Rivera, new_updated track)
   - One pending_manager (Jordan Chen, annual_renewal, employee signature already recorded)
   - One completed (Sam Washington, new_updated, all 3 signatures, with audit log entries)

   Include matching signatures and audit_log entries for the non-draft agreements.

   Seed one form_versions entry with a version hash and label "v1.0".

Apply both migrations:
```
ssh vps "docker exec -i supabase-db psql -U postgres -d postgres" < sql/003-rls-policies.sql
ssh vps "docker exec -i supabase-db psql -U postgres -d postgres" < sql/004-seed-data.sql
```
  </action>
  <verify>
Verify RLS is enabled:
```
ssh vps "docker exec supabase-db psql -U postgres -d postgres -c \"SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname='ecos'\""
```
All tables should show `t` for rowsecurity.

Verify seed data:
```
ssh vps "docker exec supabase-db psql -U postgres -d postgres -c 'SELECT first_name, last_name, role FROM ecos.employees ORDER BY role, last_name'"
```
Should show 8 employees across 3 roles.

Verify PostgREST can read through RLS:
```
curl -s "http://212.38.95.33:8000/rest/v1/employees?select=first_name,last_name,role" \
  -H "apikey: <ANON_KEY>" \
  -H "Accept: application/json"
```
Should return all 8 employees.
  </verify>
  <done>RLS enabled on all 7 tables with demo-appropriate policies. Production policy patterns documented in SQL comments. 8 fictional employees, 4 departments, 3 agreements in varying states seeded. PostgREST serves data through RLS.</done>
</task>

<task type="auto">
  <name>Task 2: Create React role context and demo identity system</name>
  <files>src/context/RoleContext.jsx, src/lib/api/agreements.js, src/lib/api/workflow.js, src/pages/AgreementPage.jsx</files>
  <action>
1. Create `src/context/RoleContext.jsx`:
   - React context providing current demo identity
   - State: `{ currentEmployee, role, departmentId }`
   - `switchRole(employeeId)` — fetches employee record, updates context
   - `useRole()` hook for consuming components
   - Default to first employee in seed data on mount (fetch employees, pick first)
   - Store selected employee ID in localStorage for persistence across page reloads

2. Wrap the app with RoleProvider in `src/main.jsx` (inside BrowserRouter).

3. Update `src/lib/api/agreements.js` and `src/lib/api/workflow.js` to accept an optional `currentEmployeeId` parameter for role-aware filtering:
   - `getPendingForRole(role, departmentId)` — filter agreements needing this role's action
   - `getAgreementsByEmployee(employeeId)` — employee sees own agreements
   - Manager sees agreements from their department
   - Admin sees all agreements

4. Update `src/pages/AgreementPage.jsx` to replace the component preview showcase with a basic data verification view:
   - Import useRole hook
   - Display current role identity (name, role, department)
   - Fetch and display agreements count from Supabase
   - Show a simple "Connected to database" indicator
   - This is a TEMPORARY verification view — Phase 3 will replace it with the actual form

This task proves the full stack works: React → Supabase client → Kong → PostgREST → PostgreSQL (ecos schema with RLS) → data back to React.
  </action>
  <verify>
Start dev server and verify:
```
cd /Users/slate/Documents/GitHub/Automation/ECOS && npm run dev
```

1. Open http://localhost:5180/ecosform/
2. Agreement page shows current demo identity
3. Agreement page shows data fetched from Supabase (departments count, employees count, agreements count)
4. No console errors
5. Build passes: `npm run build`
  </verify>
  <done>Role context provides switchable demo identity. API helpers accept role-aware parameters. AgreementPage displays live Supabase data proving full stack connectivity. Build passes.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Full database stack: 7 tables in ecos schema, RLS policies, seed data, Supabase JS client, API helpers, role context, and AgreementPage showing live data from VPS Supabase.</what-built>
  <how-to-verify>
    1. Run: `cd /Users/slate/Documents/GitHub/Automation/ECOS && npm run dev`
    2. Visit: http://localhost:5180/ecosform/
    3. Verify: AgreementPage shows current demo identity (employee name, role, department)
    4. Verify: Page displays data counts fetched from Supabase (departments, employees, agreements)
    5. Verify: No console errors in browser dev tools
    6. Verify: Network tab shows successful requests to VPS Supabase (212.38.95.33:8000)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring Phase 2 complete:
- [ ] All 7 ecos tables exist with correct schema
- [ ] RLS enabled on all tables
- [ ] 8 fictional employees, 4 departments, 3 agreements seeded
- [ ] Supabase JS client connects from React dev server to VPS
- [ ] API helper modules provide clean data access interface
- [ ] Role context switches demo identity
- [ ] AgreementPage displays live data from database
- [ ] `npm run build` succeeds
- [ ] No credentials in committed code (only in .env.local)
- [ ] SQL migration files committed (sql/001 through 004)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Full stack proven: React → Supabase → PostgreSQL → data displayed
- Role simulation system ready for Phase 5 role switcher
- Schema supports Phase 3 (form), Phase 4 (workflow), Phase 6 (dashboard)
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-api/02-03-SUMMARY.md`
</output>
