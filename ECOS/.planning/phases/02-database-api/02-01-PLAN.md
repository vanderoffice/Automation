---
phase: 02-database-api
plan: 01
type: execute
---

<objective>
Create the ECOS database schema in the existing VPS Supabase instance — tables for departments, employees, agreements, access groups, signatures, and audit logging.

Purpose: Establish the data foundation that all subsequent phases depend on (forms, workflow, dashboard, role switching). Using a dedicated `ecos` schema keeps ECOS tables isolated from other Supabase projects on the same instance.
Output: SQL migration file applied to VPS Supabase, all tables created and verified.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 summaries (dependency graph: 01 affects 02)
@.planning/phases/01-foundation/01-01-SUMMARY.md

**Tech stack available:** React 18, Vite 5, Tailwind CSS 3, React Router v6
**Established patterns:** vanderdev-design-system, multi-stage-dockerfile, layout-route-with-outlet
**Key files:** docker-compose.yml, src/App.jsx, src/main.jsx

**Constraining decisions:**
- Phase 01-01: VIRTUAL_PATH=/ecosform for prod deployment
- PROJECT.md: Supabase PostgREST backend, no PII in demo data, fictional employees/departments

**VPS Supabase access:**
- Kong API gateway: VPS port 8000 (public)
- Database: `supabase-db` container, user `postgres`, password in `/root/n8n-cloud-stack/.env`
- Existing schemas: public (3 tables), ai_solutions, kiddobot — ECOS gets its own schema
- ANON_KEY and SERVICE_ROLE_KEY available in same .env

**Schema design notes:**
- Two form tracks: New/Updated User and Annual Renewal
- Three-party workflow: Employee → Manager → Department Admin
- Audit metadata per signature: timestamp, IP, user agent, session hash, form version hash
- Access groups match ECOS user groups from original PDF form
- Demo data uses fictional names/departments (no PII)
- Architecture should support future form conversions (reusable patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ECOS schema and core tables</name>
  <files>sql/001-schema.sql</files>
  <action>
Create a SQL migration file `sql/001-schema.sql` that:

1. Creates schema `ecos` and sets search_path
2. Creates `ecos.departments` table:
   - id (uuid, PK, default gen_random_uuid())
   - name (text, not null, unique) — e.g., "Office of Digital Innovation"
   - code (text, not null, unique) — e.g., "ODI"
   - created_at (timestamptz, default now())

3. Creates `ecos.employees` table:
   - id (uuid, PK, default gen_random_uuid())
   - employee_number (text, not null, unique) — fictional
   - first_name (text, not null)
   - last_name (text, not null)
   - email (text, not null, unique) — fictional @example.gov
   - title (text)
   - department_id (uuid, FK → departments, not null)
   - role (text, not null, check in 'employee','manager','admin') — demo role
   - is_active (boolean, default true)
   - created_at (timestamptz, default now())

4. Creates `ecos.agreements` table:
   - id (uuid, PK, default gen_random_uuid())
   - employee_id (uuid, FK → employees, not null)
   - track (text, not null, check in 'new_updated','annual_renewal')
   - status (text, not null, default 'draft', check in 'draft','pending_employee','pending_manager','pending_admin','completed','expired')
   - fiscal_year (text, not null) — e.g., "2025-2026"
   - supervisor_name (text)
   - work_phone (text)
   - work_location (text)
   - form_version_hash (text) — SHA-256 of form content at time of creation
   - created_at (timestamptz, default now())
   - updated_at (timestamptz, default now())
   - completed_at (timestamptz)
   - expires_at (timestamptz)

5. Creates `ecos.agreement_access_groups` table (junction):
   - id (uuid, PK, default gen_random_uuid())
   - agreement_id (uuid, FK → agreements, not null, on delete cascade)
   - group_name (text, not null) — e.g., "CalATERS", "CalHR Benefits", "PIMS", etc.
   - access_level (text, default 'standard')
   - created_at (timestamptz, default now())
   - Unique constraint on (agreement_id, group_name)

Add indexes: employees(department_id), employees(role), agreements(employee_id), agreements(status), agreement_access_groups(agreement_id).

Create an `updated_at` trigger function and apply it to agreements.

Do NOT create RLS policies yet — that's Plan 02-03.

Apply the migration by running:
```
ssh vps "docker exec -i supabase-db psql -U postgres -d postgres" < sql/001-schema.sql
```
  </action>
  <verify>
SSH to VPS and verify tables exist:
```
ssh vps "docker exec supabase-db psql -U postgres -d postgres -c '\dt ecos.*'"
```
Should show: departments, employees, agreements, agreement_access_groups (4 tables).

Verify columns:
```
ssh vps "docker exec supabase-db psql -U postgres -d postgres -c '\d ecos.agreements'"
```
  </verify>
  <done>4 tables created in `ecos` schema with correct columns, constraints, foreign keys, and indexes. Migration file committed at sql/001-schema.sql.</done>
</task>

<task type="auto">
  <name>Task 2: Create workflow and audit tables</name>
  <files>sql/002-workflow.sql</files>
  <action>
Create `sql/002-workflow.sql` that:

1. Creates `ecos.signatures` table:
   - id (uuid, PK, default gen_random_uuid())
   - agreement_id (uuid, FK → agreements, not null, on delete cascade)
   - signer_id (uuid, FK → employees, not null)
   - signer_role (text, not null, check in 'employee','manager','admin')
   - typed_name (text, not null) — the typed signature
   - certified (boolean, not null, default false) — "I certify" checkbox
   - ip_address (inet)
   - user_agent (text)
   - session_hash (text) — SHA-256 of session identifier
   - form_version_hash (text) — SHA-256 of form content at signing time
   - signed_at (timestamptz, not null, default now())
   - Unique constraint on (agreement_id, signer_role) — one signature per role per agreement

2. Creates `ecos.audit_log` table:
   - id (uuid, PK, default gen_random_uuid())
   - agreement_id (uuid, FK → agreements, on delete set null)
   - actor_id (uuid, FK → employees, on delete set null)
   - action (text, not null) — 'created', 'submitted', 'signed', 'approved', 'rejected', 'expired', 'viewed'
   - details (jsonb) — flexible metadata (old_status, new_status, ip, user_agent, etc.)
   - ip_address (inet)
   - created_at (timestamptz, default now())

3. Creates `ecos.form_versions` table (tracks form content versions for hash verification):
   - id (uuid, PK, default gen_random_uuid())
   - version_hash (text, not null, unique) — SHA-256
   - version_label (text, not null) — e.g., "v1.0", "v1.1"
   - content_snapshot (jsonb) — the form structure/content at that version
   - created_at (timestamptz, default now())

Add indexes: signatures(agreement_id), signatures(signer_id), audit_log(agreement_id), audit_log(actor_id), audit_log(action), audit_log(created_at DESC), form_versions(version_hash).

Expose the `ecos` schema to PostgREST by running:
```sql
GRANT USAGE ON SCHEMA ecos TO anon, authenticated;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA ecos TO anon, authenticated;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA ecos TO anon, authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA ecos GRANT SELECT, INSERT, UPDATE ON TABLES TO anon, authenticated;
ALTER DEFAULT PRIVILEGES IN SCHEMA ecos GRANT USAGE, SELECT ON SEQUENCES TO anon, authenticated;
```

Then update the PostgREST config to expose the `ecos` schema. Check the current config:
```
ssh vps "docker exec supabase-rest env | grep PGRST_DB_SCHEMAS"
```

If it only shows `public`, update the docker-compose to add `ecos`:
```
ssh vps "grep -n 'PGRST_DB_SCHEMAS' /root/n8n-cloud-stack/docker-compose.yml"
```
Add `ecos` to the comma-separated list and restart supabase-rest.

Apply migration:
```
ssh vps "docker exec -i supabase-db psql -U postgres -d postgres" < sql/002-workflow.sql
```
  </action>
  <verify>
Verify tables:
```
ssh vps "docker exec supabase-db psql -U postgres -d postgres -c '\dt ecos.*'"
```
Should show 7 tables total: departments, employees, agreements, agreement_access_groups, signatures, audit_log, form_versions.

Verify PostgREST exposes ecos schema — test with curl:
```
curl -s "http://212.38.95.33:8000/rest/v1/" -H "apikey: ANON_KEY" -H "Accept: application/json" | head -20
```
(Replace ANON_KEY with actual key)

The ecos tables should be accessible through PostgREST.
  </verify>
  <done>7 tables total in `ecos` schema. PostgREST configured to expose `ecos` schema. API returns table metadata when queried. Migration files committed.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `ssh vps "docker exec supabase-db psql -U postgres -d postgres -c '\dt ecos.*'"` shows 7 tables
- [ ] All foreign key constraints verified (insert test row, verify cascade)
- [ ] PostgREST serves ecos schema tables via Kong API gateway
- [ ] SQL migration files exist at sql/001-schema.sql and sql/002-workflow.sql
- [ ] No errors in supabase-db or supabase-rest container logs
</verification>

<success_criteria>
- All 7 tables created with correct columns, types, constraints, and indexes
- Foreign keys enforce referential integrity
- updated_at trigger fires on agreements table
- PostgREST exposes ecos schema through Kong
- Migration files are idempotent (use IF NOT EXISTS where possible)
- No impact on existing public schema tables
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-api/02-01-SUMMARY.md`
</output>
